### Conceptual Exercise

Answer the following questions below:

- What is a JWT?

JWT stands for a JSON Web Token. It is a way to securely transmit information over HTTP.
The three parts of the JWT is the header, payload, and signature. The header contains metadata,
the payload contains the actual information, and the signature.  The signature is generated by signing the header and the payload with a secret key.  If any part of the JWT is tampered with, the signature will become invalid.

- What is the signature portion of the JWT?  What does it do?

The signature is the result of concatenating the header with the payload then hashing that data with a secret key. The signature portion of the JWT ensures that the token cannot be tampered with.  Only the server can create tokens because only the server knows the secret key used in the hash.

- If a JWT is intercepted, can the attacker see what's inside the payload?

YES! With a standard HS256 signature, the header and the payload are not encrypted.  So an attacker can easily see what's inside both.  The signature just ensures that that data cannot be changed. It doesn't ensure that the data is private.  So do not put sensitive data inside the JWT.

- How can you implement authentication with a JWT?  Describe how it works at a high level.

The user sends a request to create an account or to login. If the login/creating is successful, a JWT is created on the server side using a secret key that only the server knows.  The payload in the JWT contains something that will uniquely identify the user (like a user id).  The client must save the token somehow.  Typical ways to save the token are in local storage or as a cookie.  To make an authenticated request, the client must provide the token as specified by the server.  Typically the token is sent in a header called Authorization.  The server will then verify the token. To verify, the server take the header and payload and tries to sign that data using the secret key.  If the signature in the token matches the signature presented, then the token is verified. The server then looks inside the payload of the token to get the unique identifier for the user to figure out which user has been authenticated.


- Compare and contrast unit, integration and end-to-end tests.

Unit tests are inexpensive, not time consuming and test units in isolation. They provide the least amount of coverage, but are easily maintainable. Integration tests are focused around the integration of units and are a bit more time consuming to write. They cover more code than unit tests, but are a bit more brittle. End to end tests cover the entire use experience and can be useful for complete coverage, but they are quite brittle.

- What is a mock? What are some things you would mock?

A mock is a "fake" version of something - usually a function or even entire library. Mocking is common when trying to completely unit test in isolation. You might mock HTTP calls, the file system module, impure functions like Math.random and even a database.

- What is continuous integration?

CI is the practice of constantly deploying small pieces of code instead of large chunks infrequently. CI allows for quick iteration and tooling around ensuring tests pass before deployments occur.

- What is an environment variable and what are they used for?

An environment variable is a variable that is accessible by multiple applications in that environment.
Just like a global variable in a file is accessible by that entire file, environment variables can be accessed across the entire environment which is why in an application we can bring in environment variables into any file. Typically we use them when we need to keep things secret since environment variables won't be seen directly if .env is in .gitignore. We can also use them if we need to access something everywhere.


- What is TDD? What are some benefits and drawbacks?

TDD stands for test driven development and is a testing philosophy centered around writing tests first, seeing the tests fail, writing only the code necessary to get the tests to pass and then repeating/refactoring. The benefits include a solid test suite from the beginning, but the drawbacks include a more time consuming and potentially inefficient development process. 


- What is the value of using JSONSchema for validation?

JSONSchema can allow for a more specific validation scheme than if everything was coded in JS. For example, to verify 15 inputs it would take a lot of if-else statements to get exactly the validation that you would like. This makes the code unreadable. JSONSchema will also allow for standardization. For example, even for a couple of inputs there are many different ways validation can be done.

- What are some ways to decide which code to test?

If tests cannot be done for every line of code then the places to target are code that is complex since this code is more likely to have bugs just because of the inherent complexity. Another area to target would be code that is used a lot in an application. For example, if one route is going to be hit way more than others it would be beneficial to test this route.

- What are some differences between Web Sockets and HTTP?

Web socket is another communication method other than HTTP. Web socket allows the connection to the server to stay open so that open communication between the client and server can take place. Other than chat systems they are good for any sort of environment in which there are multiple people working together. For example in google docs you can work with another person in the same doc and you can see in real time what they are changing. Web sockets maintain a connection and have much less overhead than HTTP.

- Did you prefer using Flask over Express? Why or why not (there is no right answer here - we want to see how you think about technology)?

This is totally a matter of opinion! Express is a bit more minimalist than Flask and it requires even more setup sometimes, and the asynchronous nature of Node can be quite challenging. 